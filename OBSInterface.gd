extends Control

onready var connect_obs:WindowDialog = $OBSConnect
onready var current_scene:Label = $VB/CurrentScene
onready var scene_list:ItemList = $VB/HB/Column1/ItemList
onready var scene_item_list:ItemList = $VB/HB/Column2/ItemList
onready var obs:ObsWs = $ObsWs

var scenes:Array
var internal:bool
var last_scene:int

func _ready() -> void:
	# Connect to events emitted from the ObsWs node, to be used in our program.
	obs.connect("obs_connected", self, "_on_obs_connected")
	obs.connect("obs_disconnected", self, "_on_obs_disconnected")
	obs.connect("obs_event", self, "_on_obs_event")
	obs.connect("obs_response", self, "_on_obs_response")
	obs.connect("obs_error", self, "_on_obs_error")
	scene_list.clear()
	scene_item_list.clear()
	scenes = []
	connect_obs.popup_centered()

func _on_obs_connected() -> void:
	# Once we connect, we need to get a list of Scenes, send this command to get
	# this list.
	obs.command("GetSceneList",{})

func _on_obs_disconnected() -> void:
	# When we get disconnected, popup our dialog to show to the end user to re-connect.
	connect_obs.popup_centered()

func _on_obs_event(event:String, data:Dictionary) -> void:
	# These are Events that are generated by user input on OBS, that OBS WebSocket sends out.
	match event:
		# The user switch scenes, so we need to update our view to properly to show the selected
		# scene as well as the Scene Items that are in that scene.
		"SwitchScenes":
			for scene in scenes:
				if scene.name == data.scene_name:
					internal = true
					scene_list.select(scenes.find(scene))
					_on_ItemList_item_selected(scenes.find(scene))
		_:
			# This is a Generic handler, for any events that we do not match above, so we can see
			# the output of each of these events.
			print("[ObsWs/EVENT] %s:> %s" % [event, str(data)])

func _on_obs_response(command:String, data:Dictionary) -> void:
	# This is where we get responses from the commands we issue through our client.
	match command:
		# This returns the Array of Scenes that are defined in OBS, as well as the Current Scene
		# that is selected in the client.
		"GetSceneList":
			scenes = data.scenes
			current_scene.text = "Current Scene: %s" % data.current_scene
			for scene in data.scenes:
				scene_list.add_item(scene.name)
				if (scene.name == data.current_scene):
					internal = true
					scene_list.select(scenes.find(scene))
					_on_ItemList_item_selected(scenes.find(scene))
		# This is a response to our SetCurrentScene, which is executed below, the only value returned
		# is status, which should be OK if everything ocurred as it should.
		"SetCurrentScene":
			if data.status != "ok":
				# We do internal here, so we are not bombarding the OBS WebSocket with subsequent SetCurrentScene
				# commands, when we update our Scene List, and the collection of scene items within the scene.
				internal = true
				scene_list.select(last_scene)
				_on_ItemList_item_selected(last_scene)
			else:
				# Something failed on OBS side, so we need to revert back to the last selected scene.
				last_scene = scene_list.get_selected_items()[0]
		_:
			# This is a Default handler for all responses from OBS Websocket, for any commands that are
			# isseud.
			print("[ObsWs/RESPONSE] %s:> %s" % [command, str(data)])

func _on_obs_error(error:Dictionary):
	# This is a handler for any OBS Error that ocurrs.  This has 2 internal errors for connection and 
	# Data packet error.
	printerr("[ObsWs/ERROR]> %s" % str(error))


func _on_ItemList_item_selected(index: int) -> void:
	# Here we handle user input in our application, to change scenes on the OBS Side of things, to match
	# what we have selected here.  If internal is true, then we do not generate another command to
	# OBS to update the current scene on OBS side.
	scene_item_list.clear()
	for scene_item in scenes[index].sources:
		scene_item_list.add_item(scene_item.name)
	if (internal):
		last_scene = index
		internal = false
		return
	obs.command("SetCurrentScene", {"scene-name": scenes[index].name})
